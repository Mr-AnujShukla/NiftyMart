{"ast":null,"code":"import _slicedToArray from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\";\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport var format = function format(link, base) {\n  var bytes = link.bytes,\n    version = link.version;\n  switch (version) {\n    case 0:\n      return toStringV0(bytes, baseCache(link), /** @type {API.MultibaseEncoder<\"z\">} */base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, baseCache(link), /** @type {API.MultibaseEncoder<Prefix>} */base || base32.encoder);\n  }\n};\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nvar cache = new WeakMap();\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nvar baseCache = function baseCache(cid) {\n  var baseCache = cache.get(cid);\n  if (baseCache == null) {\n    var _baseCache = new Map();\n    cache.set(cid, _baseCache);\n    return _baseCache;\n  }\n  return baseCache;\n};\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport var CID = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$for) {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  function CID(version, code, multihash, bytes) {\n    _classCallCheck(this, CID);\n    /** @readonly */\n    this.code = code;\n    /** @readonly */\n    this.version = version;\n    /** @readonly */\n    this.multihash = multihash;\n    /** @readonly */\n    this.bytes = bytes;\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes;\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  _createClass(CID, [{\n    key: \"asCID\",\n    get: function get() {\n      return this;\n    }\n\n    // ArrayBufferView\n  }, {\n    key: \"byteOffset\",\n    get: function get() {\n      return this.bytes.byteOffset;\n    }\n\n    // ArrayBufferView\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this.bytes.byteLength;\n    }\n\n    /**\n     * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n     */\n  }, {\n    key: \"toV0\",\n    value: function toV0() {\n      switch (this.version) {\n        case 0:\n          {\n            return (/** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */this\n            );\n          }\n        case 1:\n          {\n            var code = this.code,\n              multihash = this.multihash;\n            if (code !== DAG_PB_CODE) {\n              throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n            }\n\n            // sha2-256\n            if (multihash.code !== SHA_256_CODE) {\n              throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n            }\n            return (/** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */\n              CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */multihash)\n            );\n          }\n        default:\n          {\n            throw Error(\"Can not convert CID version \".concat(this.version, \" to version 0. This is a bug please report\"));\n          }\n      }\n    }\n\n    /**\n     * @returns {CID<Data, Format, Alg, 1>}\n     */\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      switch (this.version) {\n        case 0:\n          {\n            var _this$multihash = this.multihash,\n              code = _this$multihash.code,\n              digest = _this$multihash.digest;\n            var multihash = Digest.create(code, digest);\n            return (/** @type {CID<Data, Format, Alg, 1>} */\n              CID.createV1(this.code, multihash)\n            );\n          }\n        case 1:\n          {\n            return (/** @type {CID<Data, Format, Alg, 1>} */this\n            );\n          }\n        default:\n          {\n            throw Error(\"Can not convert CID version \".concat(this.version, \" to version 1. This is a bug please report\"));\n          }\n      }\n    }\n\n    /**\n     * @param {unknown} other\n     * @returns {other is CID<Data, Format, Alg, Version>}\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return CID.equals(this, other);\n    }\n\n    /**\n     * @template {unknown} Data\n     * @template {number} Format\n     * @template {number} Alg\n     * @template {API.Version} Version\n     * @param {API.Link<Data, Format, Alg, Version>} self\n     * @param {unknown} other\n     * @returns {other is CID}\n     */\n  }, {\n    key: \"toString\",\n    value:\n    /**\n     * @param {API.MultibaseEncoder<string>} [base]\n     * @returns {string}\n     */\n    function toString(base) {\n      return format(this, base);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        code: this.code,\n        version: this.version,\n        hash: this.multihash.bytes\n      };\n    }\n  }, {\n    key: \"link\",\n    value: function link() {\n      return this;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return 'CID';\n    }\n\n    // Legacy\n  }, {\n    key: _Symbol$for,\n    value: function value() {\n      return \"CID(\".concat(this.toString(), \")\");\n    }\n\n    /**\n     * Takes any input `value` and returns a `CID` instance if it was\n     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n     * it will return value back. If `value` is not instance of this CID\n     * class, but is compatible CID it will return new instance of this\n     * `CID` class. Otherwise returs null.\n     *\n     * This allows two different incompatible versions of CID library to\n     * co-exist and interop as long as binary interface is compatible.\n     *\n     * @template {unknown} Data\n     * @template {number} Format\n     * @template {number} Alg\n     * @template {API.Version} Version\n     * @template {unknown} U\n     * @param {API.Link<Data, Format, Alg, Version>|U} input\n     * @returns {CID<Data, Format, Alg, Version>|null}\n     */\n  }], [{\n    key: \"equals\",\n    value: function equals(self, other) {\n      var unknown = /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */\n      other;\n      return unknown && self.code === unknown.code && self.version === unknown.version && Digest.equals(self.multihash, unknown.multihash);\n    }\n  }, {\n    key: \"asCID\",\n    value: function asCID(input) {\n      if (input == null) {\n        return null;\n      }\n      var value = /** @type {any} */input;\n      if (value instanceof CID) {\n        // If value is instance of CID then we're all set.\n        return value;\n      } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {\n        // If value isn't instance of this CID class but `this.asCID === this` or\n        // `value['/'] === value.bytes` is true it is CID instance coming from a\n        // different implementation (diff version or duplicate). In that case we\n        // rebase it to this `CID` implementation so caller is guaranteed to get\n        // instance with expected API.\n        var version = value.version,\n          code = value.code,\n          multihash = value.multihash,\n          bytes = value.bytes;\n        return new CID(version, code, /** @type {API.MultihashDigest<Alg>} */multihash, bytes || encodeCID(version, code, multihash.bytes));\n      } else if (value[cidSymbol] === true) {\n        // If value is a CID from older implementation that used to be tagged via\n        // symbol we still rebase it to the this `CID` implementation by\n        // delegating that to a constructor.\n        var _version = value.version,\n          _multihash = value.multihash,\n          _code = value.code;\n        var digest = /** @type {API.MultihashDigest<Alg>} */\n        Digest.decode(_multihash);\n        return CID.create(_version, _code, digest);\n      } else {\n        // Otherwise value is not a CID (or an incompatible version of it) in\n        // which case we return `null`.\n        return null;\n      }\n    }\n\n    /**\n     *\n     * @template {unknown} Data\n     * @template {number} Format\n     * @template {number} Alg\n     * @template {API.Version} Version\n     * @param {Version} version - Version of the CID\n     * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n     * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n     * @returns {CID<Data, Format, Alg, Version>}\n     */\n  }, {\n    key: \"create\",\n    value: function create(version, code, digest) {\n      if (typeof code !== 'number') {\n        throw new Error('String codecs are no longer supported');\n      }\n      if (!(digest.bytes instanceof Uint8Array)) {\n        throw new Error('Invalid digest');\n      }\n      switch (version) {\n        case 0:\n          {\n            if (code !== DAG_PB_CODE) {\n              throw new Error(\"Version 0 CID must use dag-pb (code: \".concat(DAG_PB_CODE, \") block encoding\"));\n            } else {\n              return new CID(version, code, digest, digest.bytes);\n            }\n          }\n        case 1:\n          {\n            var bytes = encodeCID(version, code, digest.bytes);\n            return new CID(version, code, digest, bytes);\n          }\n        default:\n          {\n            throw new Error('Invalid version');\n          }\n      }\n    }\n\n    /**\n     * Simplified version of `create` for CIDv0.\n     *\n     * @template {unknown} [T=unknown]\n     * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n     * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n     */\n  }, {\n    key: \"createV0\",\n    value: function createV0(digest) {\n      return CID.create(0, DAG_PB_CODE, digest);\n    }\n\n    /**\n     * Simplified version of `create` for CIDv1.\n     *\n     * @template {unknown} Data\n     * @template {number} Code\n     * @template {number} Alg\n     * @param {Code} code - Content encoding format code.\n     * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n     * @returns {CID<Data, Code, Alg, 1>}\n     */\n  }, {\n    key: \"createV1\",\n    value: function createV1(code, digest) {\n      return CID.create(1, code, digest);\n    }\n\n    /**\n     * Decoded a CID from its binary representation. The byte array must contain\n     * only the CID with no additional bytes.\n     *\n     * An error will be thrown if the bytes provided do not contain a valid\n     * binary representation of a CID.\n     *\n     * @template {unknown} Data\n     * @template {number} Code\n     * @template {number} Alg\n     * @template {API.Version} Ver\n     * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n     * @returns {CID<Data, Code, Alg, Ver>}\n     */\n  }, {\n    key: \"decode\",\n    value: function decode(bytes) {\n      var _CID$decodeFirst = CID.decodeFirst(bytes),\n        _CID$decodeFirst2 = _slicedToArray(_CID$decodeFirst, 2),\n        cid = _CID$decodeFirst2[0],\n        remainder = _CID$decodeFirst2[1];\n      if (remainder.length) {\n        throw new Error('Incorrect length');\n      }\n      return cid;\n    }\n\n    /**\n     * Decoded a CID from its binary representation at the beginning of a byte\n     * array.\n     *\n     * Returns an array with the first element containing the CID and the second\n     * element containing the remainder of the original byte array. The remainder\n     * will be a zero-length byte array if the provided bytes only contained a\n     * binary CID representation.\n     *\n     * @template {unknown} T\n     * @template {number} C\n     * @template {number} A\n     * @template {API.Version} V\n     * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n     * @returns {[CID<T, C, A, V>, Uint8Array]}\n     */\n  }, {\n    key: \"decodeFirst\",\n    value: function decodeFirst(bytes) {\n      var specs = CID.inspectBytes(bytes);\n      var prefixSize = specs.size - specs.multihashSize;\n      var multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n      if (multihashBytes.byteLength !== specs.multihashSize) {\n        throw new Error('Incorrect length');\n      }\n      var digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n      var digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n      var cid = specs.version === 0 ? CID.createV0( /** @type {API.MultihashDigest<API.SHA_256>} */digest) : CID.createV1(specs.codec, digest);\n      return [/** @type {CID<T, C, A, V>} */cid, bytes.subarray(specs.size)];\n    }\n\n    /**\n     * Inspect the initial bytes of a CID to determine its properties.\n     *\n     * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n     * bytes but for larger multicodec code values and larger multihash digest\n     * lengths these varints can be quite large. It is recommended that at least\n     * 10 bytes be made available in the `initialBytes` argument for a complete\n     * inspection.\n     *\n     * @template {unknown} T\n     * @template {number} C\n     * @template {number} A\n     * @template {API.Version} V\n     * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n     * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n     */\n  }, {\n    key: \"inspectBytes\",\n    value: function inspectBytes(initialBytes) {\n      var offset = 0;\n      var next = function next() {\n        var _varint$decode = varint.decode(initialBytes.subarray(offset)),\n          _varint$decode2 = _slicedToArray(_varint$decode, 2),\n          i = _varint$decode2[0],\n          length = _varint$decode2[1];\n        offset += length;\n        return i;\n      };\n      var version = /** @type {V} */next();\n      var codec = /** @type {C} */DAG_PB_CODE;\n      if ( /** @type {number} */version === 18) {\n        // CIDv0\n        version = /** @type {V} */0;\n        offset = 0;\n      } else {\n        codec = /** @type {C} */next();\n      }\n      if (version !== 0 && version !== 1) {\n        throw new RangeError(\"Invalid CID version \".concat(version));\n      }\n      var prefixSize = offset;\n      var multihashCode = /** @type {A} */next(); // multihash code\n      var digestSize = next(); // multihash length\n      var size = offset + digestSize;\n      var multihashSize = size - prefixSize;\n      return {\n        version: version,\n        codec: codec,\n        multihashCode: multihashCode,\n        digestSize: digestSize,\n        multihashSize: multihashSize,\n        size: size\n      };\n    }\n\n    /**\n     * Takes cid in a string representation and creates an instance. If `base`\n     * decoder is not provided will use a default from the configuration. It will\n     * throw an error if encoding of the CID is not compatible with supplied (or\n     * a default decoder).\n     *\n     * @template {string} Prefix\n     * @template {unknown} Data\n     * @template {number} Code\n     * @template {number} Alg\n     * @template {API.Version} Ver\n     * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n     * @param {API.MultibaseDecoder<Prefix>} [base]\n     * @returns {CID<Data, Code, Alg, Ver>}\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(source, base) {\n      var _parseCIDtoBytes = parseCIDtoBytes(source, base),\n        _parseCIDtoBytes2 = _slicedToArray(_parseCIDtoBytes, 2),\n        prefix = _parseCIDtoBytes2[0],\n        bytes = _parseCIDtoBytes2[1];\n      var cid = CID.decode(bytes);\n\n      // Cache string representation to avoid computing it on `this.toString()`\n      baseCache(cid).set(prefix, source);\n      return cid;\n    }\n  }]);\n  return CID;\n}(Symbol.toStringTag, Symbol.for('nodejs.util.inspect.custom'));\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nvar parseCIDtoBytes = function parseCIDtoBytes(source, base) {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q':\n      {\n        var decoder = base || base58btc;\n        return [/** @type {Prefix} */base58btc.prefix, decoder.decode(\"\".concat(base58btc.prefix).concat(source))];\n      }\n    case base58btc.prefix:\n      {\n        var _decoder = base || base58btc;\n        return [/** @type {Prefix} */base58btc.prefix, _decoder.decode(source)];\n      }\n    case base32.prefix:\n      {\n        var _decoder2 = base || base32;\n        return [/** @type {Prefix} */base32.prefix, _decoder2.decode(source)];\n      }\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n        return [/** @type {Prefix} */source[0], base.decode(source)];\n      }\n  }\n};\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nvar toStringV0 = function toStringV0(bytes, cache, base) {\n  var prefix = base.prefix;\n  if (prefix !== base58btc.prefix) {\n    throw Error(\"Cannot string encode V0 in \".concat(base.name, \" encoding\"));\n  }\n  var cid = cache.get(prefix);\n  if (cid == null) {\n    var _cid = base.encode(bytes).slice(1);\n    cache.set(prefix, _cid);\n    return _cid;\n  } else {\n    return cid;\n  }\n};\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nvar toStringV1 = function toStringV1(bytes, cache, base) {\n  var prefix = base.prefix;\n  var cid = cache.get(prefix);\n  if (cid == null) {\n    var _cid2 = base.encode(bytes);\n    cache.set(prefix, _cid2);\n    return _cid2;\n  } else {\n    return cid;\n  }\n};\nvar DAG_PB_CODE = 0x70;\nvar SHA_256_CODE = 0x12;\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nvar encodeCID = function encodeCID(version, code, multihash) {\n  var codeOffset = varint.encodingLength(version);\n  var hashOffset = codeOffset + varint.encodingLength(code);\n  var bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nvar cidSymbol = Symbol.for('@ipld/js-cid/CID');","map":{"version":3,"names":["varint","Digest","base58btc","base32","coerce","API","format","link","base","bytes","version","toStringV0","baseCache","encoder","toStringV1","cache","WeakMap","cid","get","Map","set","CID","code","multihash","byteOffset","byteLength","DAG_PB_CODE","Error","SHA_256_CODE","createV0","digest","create","createV1","other","equals","hash","toString","self","unknown","input","value","asCID","encodeCID","cidSymbol","decode","Uint8Array","decodeFirst","remainder","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","codec","initialBytes","offset","next","i","RangeError","source","parseCIDtoBytes","prefix","Symbol","toStringTag","for","decoder","name","encode","slice","codeOffset","encodingLength","hashOffset","encodeTo"],"sources":["C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/multiformats/src/cid.js"],"sourcesContent":["import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returs null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}