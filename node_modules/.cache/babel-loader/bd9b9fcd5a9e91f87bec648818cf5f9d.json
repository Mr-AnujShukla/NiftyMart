{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CID } from 'multiformats/cid';\nimport { configure } from '../lib/configure.js';\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request';\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js';\nimport { abortSignal } from '../lib/abort-signal.js';\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport var createPut = function createPut(codecs, options) {\n  var fn = configure(function (api) {\n    /**\n     * @type {DAGAPI[\"put\"]}\n     */\n    var put = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dagNode) {\n        var options,\n          settings,\n          serialized,\n          storeCodec,\n          controller,\n          signal,\n          res,\n          data,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                settings = _objectSpread({\n                  storeCodec: 'dag-cbor',\n                  hashAlg: 'sha2-256'\n                }, options);\n                if (!settings.inputCodec) {\n                  _context.next = 8;\n                  break;\n                }\n                if (dagNode instanceof Uint8Array) {\n                  _context.next = 5;\n                  break;\n                }\n                throw new Error('Can only inputCodec on raw bytes that can be decoded');\n              case 5:\n                serialized = dagNode;\n                _context.next = 13;\n                break;\n              case 8:\n                _context.next = 10;\n                return codecs.getCodec(settings.storeCodec);\n              case 10:\n                storeCodec = _context.sent;\n                serialized = storeCodec.encode(dagNode);\n                // now we have a serialized form, the server should be told to receive it\n                // in that format\n                settings.inputCodec = settings.storeCodec;\n              case 13:\n                // allow aborting requests on body errors\n                controller = new AbortController();\n                signal = abortSignal(controller.signal, settings.signal);\n                _context.t0 = api;\n                _context.t1 = _objectSpread;\n                _context.t2 = {\n                  timeout: settings.timeout,\n                  signal: signal,\n                  searchParams: toUrlSearchParams(settings)\n                };\n                _context.next = 20;\n                return multipartRequest([serialized], controller, settings.headers);\n              case 20:\n                _context.t3 = _context.sent;\n                _context.t4 = (0, _context.t1)(_context.t2, _context.t3);\n                _context.next = 24;\n                return _context.t0.post.call(_context.t0, 'dag/put', _context.t4);\n              case 24:\n                res = _context.sent;\n                _context.next = 27;\n                return res.json();\n              case 27:\n                data = _context.sent;\n                return _context.abrupt(\"return\", CID.parse(data.Cid['/']));\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function put(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    return put;\n  });\n  return fn(options);\n};","map":{"version":3,"names":["CID","configure","multipartRequest","toUrlSearchParams","abortSignal","createPut","codecs","options","fn","api","put","dagNode","settings","storeCodec","hashAlg","inputCodec","Uint8Array","Error","serialized","getCodec","encode","controller","AbortController","signal","timeout","searchParams","headers","post","res","json","data","parse","Cid"],"sources":["C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/ipfs-http-client/src/dag/put.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { configure } from '../lib/configure.js'\nimport { multipartRequest } from 'ipfs-core-utils/multipart-request'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { abortSignal } from '../lib/abort-signal.js'\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dag').API<HTTPClientExtraOptions>} DAGAPI\n */\n\n/**\n * @param {import('ipfs-core-utils/multicodecs').Multicodecs} codecs\n * @param {import('../types').Options} options\n */\nexport const createPut = (codecs, options) => {\n  const fn = configure((api) => {\n    /**\n     * @type {DAGAPI[\"put\"]}\n     */\n    const put = async (dagNode, options = {}) => {\n      const settings = {\n        storeCodec: 'dag-cbor',\n        hashAlg: 'sha2-256',\n        ...options\n      }\n\n      let serialized\n\n      if (settings.inputCodec) {\n        // if you supply an inputCodec, we assume you're passing in a raw, encoded\n        // block using that codec, so we'll just pass that on to the server and let\n        // it deal with the decode/encode/store cycle\n        if (!(dagNode instanceof Uint8Array)) {\n          throw new Error('Can only inputCodec on raw bytes that can be decoded')\n        }\n        serialized = dagNode\n      } else {\n        // if you don't supply an inputCodec, we assume you've passed in a JavaScript\n        // object you want to have encoded using storeCodec, so we'll prepare it for\n        // you if we have the codec\n        const storeCodec = await codecs.getCodec(settings.storeCodec)\n        serialized = storeCodec.encode(dagNode)\n        // now we have a serialized form, the server should be told to receive it\n        // in that format\n        settings.inputCodec = settings.storeCodec\n      }\n\n      // allow aborting requests on body errors\n      const controller = new AbortController()\n      const signal = abortSignal(controller.signal, settings.signal)\n\n      const res = await api.post('dag/put', {\n        timeout: settings.timeout,\n        signal,\n        searchParams: toUrlSearchParams(settings),\n        ...(\n          await multipartRequest([serialized], controller, settings.headers)\n        )\n      })\n      const data = await res.json()\n\n      return CID.parse(data.Cid['/'])\n    }\n\n    return put\n  })\n\n  return fn(options)\n}\n"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,kBAAkB;AACtC,SAASC,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,gBAAgB,QAAQ,mCAAmC;AACpE,SAASC,iBAAiB,QAAQ,gCAAgC;AAClE,SAASC,WAAW,QAAQ,wBAAwB;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAS,CAAIC,MAAM,EAAEC,OAAO,EAAK;EAC5C,IAAMC,EAAE,GAAGP,SAAS,CAAC,UAACQ,GAAG,EAAK;IAC5B;AACJ;AACA;IACI,IAAMC,GAAG;MAAA,sEAAG,iBAAOC,OAAO;QAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAAEJ,OAAO,2DAAG,CAAC,CAAC;gBAChCK,QAAQ;kBACZC,UAAU,EAAE,UAAU;kBACtBC,OAAO,EAAE;gBAAU,GAChBP,OAAO;gBAAA,KAKRK,QAAQ,CAACG,UAAU;kBAAA;kBAAA;gBAAA;gBAAA,IAIfJ,OAAO,YAAYK,UAAU;kBAAA;kBAAA;gBAAA;gBAAA,MAC3B,IAAIC,KAAK,CAAC,sDAAsD,CAAC;cAAA;gBAEzEC,UAAU,GAAGP,OAAO;gBAAA;gBAAA;cAAA;gBAAA;gBAAA,OAKKL,MAAM,CAACa,QAAQ,CAACP,QAAQ,CAACC,UAAU,CAAC;cAAA;gBAAvDA,UAAU;gBAChBK,UAAU,GAAGL,UAAU,CAACO,MAAM,CAACT,OAAO,CAAC;gBACvC;gBACA;gBACAC,QAAQ,CAACG,UAAU,GAAGH,QAAQ,CAACC,UAAU;cAAA;gBAG3C;gBACMQ,UAAU,GAAG,IAAIC,eAAe,EAAE;gBAClCC,MAAM,GAAGnB,WAAW,CAACiB,UAAU,CAACE,MAAM,EAAEX,QAAQ,CAACW,MAAM,CAAC;gBAAA,cAE5Cd,GAAG;gBAAA;gBAAA;kBACnBe,OAAO,EAAEZ,QAAQ,CAACY,OAAO;kBACzBD,MAAM,EAANA,MAAM;kBACNE,YAAY,EAAEtB,iBAAiB,CAACS,QAAQ;gBAAC;gBAAA;gBAAA,OAEjCV,gBAAgB,CAAC,CAACgB,UAAU,CAAC,EAAEG,UAAU,EAAET,QAAQ,CAACc,OAAO,CAAC;cAAA;gBAAA;gBAAA;gBAAA;gBAAA,mBALhDC,IAAI,mBAAC,SAAS;cAAA;gBAA9BC,GAAG;gBAAA;gBAAA,OAQUA,GAAG,CAACC,IAAI,EAAE;cAAA;gBAAvBC,IAAI;gBAAA,iCAEH9B,GAAG,CAAC+B,KAAK,CAACD,IAAI,CAACE,GAAG,CAAC,GAAG,CAAC,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAChC;MAAA,gBA3CKtB,GAAG;QAAA;MAAA;IAAA,GA2CR;IAED,OAAOA,GAAG;EACZ,CAAC,CAAC;EAEF,OAAOF,EAAE,CAACD,OAAO,CAAC;AACpB,CAAC"},"metadata":{},"sourceType":"module"}