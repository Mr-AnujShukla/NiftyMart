{"ast":null,"code":"import _defineProperty from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport functionTimeout, { isTimeoutError } from 'function-timeout';\nimport timeSpan from 'time-span';\nimport cloneRegexp from 'clone-regexp'; // TODO: Use `structuredClone` instead when targeting Node.js 18.\n\nvar resultToMatch = function resultToMatch(result) {\n  var _result$groups;\n  return {\n    match: result[0],\n    index: result.index,\n    groups: result.slice(1),\n    namedGroups: (_result$groups = result.groups) !== null && _result$groups !== void 0 ? _result$groups : {},\n    input: result.input\n  };\n};\nexport function isMatch(regex, string) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    timeout = _ref.timeout;\n  try {\n    return functionTimeout(function () {\n      return cloneRegexp(regex).test(string);\n    }, {\n      timeout: timeout\n    })();\n  } catch (error) {\n    if (isTimeoutError(error)) {\n      return false;\n    }\n    throw error;\n  }\n}\nexport function firstMatch(regex, string) {\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    timeout = _ref2.timeout;\n  try {\n    var result = functionTimeout(function () {\n      return cloneRegexp(regex).exec(string);\n    }, {\n      timeout: timeout\n    })();\n    if (result === null) {\n      return;\n    }\n    return resultToMatch(result);\n  } catch (error) {\n    if (isTimeoutError(error)) {\n      return;\n    }\n    throw error;\n  }\n}\nexport function matches(regex, string) {\n  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref3$timeout = _ref3.timeout,\n    timeout = _ref3$timeout === void 0 ? Number.POSITIVE_INFINITY : _ref3$timeout,\n    _ref3$matchTimeout = _ref3.matchTimeout,\n    matchTimeout = _ref3$matchTimeout === void 0 ? Number.POSITIVE_INFINITY : _ref3$matchTimeout;\n  if (!regex.global) {\n    throw new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');\n  }\n  return _defineProperty({}, Symbol.iterator, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var matches, nextMatch, end, _nextMatch, value, done;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      matches = string.matchAll(regex); // The regex is only executed when iterated over.\n                    case 1:\n                      if (!true) {\n                        _context.next = 12;\n                        break;\n                      }\n                      nextMatch = functionTimeout(function () {\n                        return matches.next();\n                      }, {\n                        timeout: timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY ? Math.min(timeout, matchTimeout) : undefined\n                      }); // `matches.next` must be called within an arrow function so that it doesn't loose its context.\n                      end = timeSpan();\n                      _nextMatch = nextMatch(), value = _nextMatch.value, done = _nextMatch.done;\n                      timeout -= Math.ceil(end());\n                      if (!done) {\n                        _context.next = 8;\n                        break;\n                      }\n                      return _context.abrupt(\"break\", 12);\n                    case 8:\n                      _context.next = 10;\n                      return resultToMatch(value);\n                    case 10:\n                      _context.next = 1;\n                      break;\n                    case 12:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            })(), \"t0\", 2);\n          case 2:\n            _context2.next = 8;\n            break;\n          case 4:\n            _context2.prev = 4;\n            _context2.t1 = _context2[\"catch\"](0);\n            if (isTimeoutError(_context2.t1)) {\n              _context2.next = 8;\n              break;\n            }\n            throw _context2.t1;\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 4]]);\n  }));\n}","map":{"version":3,"names":["functionTimeout","isTimeoutError","timeSpan","cloneRegexp","resultToMatch","result","match","index","groups","slice","namedGroups","input","isMatch","regex","string","timeout","test","error","firstMatch","exec","matches","Number","POSITIVE_INFINITY","matchTimeout","global","Error","Symbol","iterator","matchAll","nextMatch","next","Math","min","undefined","end","value","done","ceil"],"sources":["C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/super-regex/index.js"],"sourcesContent":["import functionTimeout, {isTimeoutError} from 'function-timeout';\nimport timeSpan from 'time-span';\nimport cloneRegexp from 'clone-regexp'; // TODO: Use `structuredClone` instead when targeting Node.js 18.\n\nconst resultToMatch = result => ({\n\tmatch: result[0],\n\tindex: result.index,\n\tgroups: result.slice(1),\n\tnamedGroups: result.groups ?? {},\n\tinput: result.input,\n});\n\nexport function isMatch(regex, string, {timeout} = {}) {\n\ttry {\n\t\treturn functionTimeout(() => cloneRegexp(regex).test(string), {timeout})();\n\t} catch (error) {\n\t\tif (isTimeoutError(error)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function firstMatch(regex, string, {timeout} = {}) {\n\ttry {\n\t\tconst result = functionTimeout(() => cloneRegexp(regex).exec(string), {timeout})();\n\n\t\tif (result === null) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn resultToMatch(result);\n\t} catch (error) {\n\t\tif (isTimeoutError(error)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n\nexport function matches(regex, string, {timeout = Number.POSITIVE_INFINITY, matchTimeout = Number.POSITIVE_INFINITY} = {}) {\n\tif (!regex.global) {\n\t\tthrow new Error('The regex must have the global flag, otherwise, use `firstMatch()` instead');\n\t}\n\n\treturn {\n\t\t* [Symbol.iterator]() {\n\t\t\ttry {\n\t\t\t\tconst matches = string.matchAll(regex); // The regex is only executed when iterated over.\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst nextMatch = functionTimeout(() => matches.next(), {timeout: (timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY) ? Math.min(timeout, matchTimeout) : undefined}); // `matches.next` must be called within an arrow function so that it doesn't loose its context.\n\n\t\t\t\t\tconst end = timeSpan();\n\t\t\t\t\tconst {value, done} = nextMatch();\n\t\t\t\t\ttimeout -= Math.ceil(end());\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tyield resultToMatch(value);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (!isTimeoutError(error)) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}