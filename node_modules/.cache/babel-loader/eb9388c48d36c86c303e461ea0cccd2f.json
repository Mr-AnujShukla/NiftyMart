{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('./types').LoadHasherFn} LoadHasherFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadHasherFn}\n */\nvar LOAD_HASHER = function LOAD_HASHER(codeOrName) {\n  return Promise.reject(new Error(\"No hasher found for \\\"\".concat(codeOrName, \"\\\"\")));\n};\nexport var Multihashes = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {LoadHasherFn} [options.loadHasher]\n   * @param {MultihashHasher[]} options.hashers\n   */\n  function Multihashes(options) {\n    _classCallCheck(this, Multihashes);\n    // Object with current list of active hashers\n    /** @type {Record<string, MultihashHasher>}} */\n    this._hashersByName = {};\n\n    // Object with current list of active hashers\n    /** @type {Record<number, MultihashHasher>}} */\n    this._hashersByCode = {};\n    this._loadHasher = options.loadHasher || LOAD_HASHER;\n\n    // Enable all supplied hashers\n    var _iterator = _createForOfIteratorHelper(options.hashers),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var hasher = _step.value;\n        this.addHasher(hasher);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  /**\n   * Add support for a multibase hasher\n   *\n   * @param {MultihashHasher} hasher\n   */\n  _createClass(Multihashes, [{\n    key: \"addHasher\",\n    value: function addHasher(hasher) {\n      if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {\n        throw new Error(\"Resolver already exists for codec \\\"\".concat(hasher.name, \"\\\"\"));\n      }\n      this._hashersByName[hasher.name] = hasher;\n      this._hashersByCode[hasher.code] = hasher;\n    }\n\n    /**\n     * Remove support for a multibase hasher\n     *\n     * @param {MultihashHasher} hasher\n     */\n  }, {\n    key: \"removeHasher\",\n    value: function removeHasher(hasher) {\n      delete this._hashersByName[hasher.name];\n      delete this._hashersByCode[hasher.code];\n    }\n\n    /**\n     * @param {number | string} code\n     */\n  }, {\n    key: \"getHasher\",\n    value: function () {\n      var _getHasher = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(code) {\n        var table, hasher;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                table = typeof code === 'string' ? this._hashersByName : this._hashersByCode;\n                if (!table[code]) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\", table[code]);\n              case 3:\n                _context.next = 5;\n                return this._loadHasher(code);\n              case 5:\n                hasher = _context.sent;\n                if (table[code] == null) {\n                  this.addHasher(hasher);\n                }\n                return _context.abrupt(\"return\", hasher);\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getHasher(_x) {\n        return _getHasher.apply(this, arguments);\n      }\n      return getHasher;\n    }()\n  }, {\n    key: \"listHashers\",\n    value: function listHashers() {\n      return Object.values(this._hashersByName);\n    }\n  }]);\n  return Multihashes;\n}();","map":{"version":3,"names":["LOAD_HASHER","codeOrName","Promise","reject","Error","Multihashes","options","_hashersByName","_hashersByCode","_loadHasher","loadHasher","hashers","hasher","addHasher","name","code","table","Object","values"],"sources":["C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/ipfs-core-utils/src/multihashes.js"],"sourcesContent":["/**\n * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher\n * @typedef {import('./types').LoadHasherFn} LoadHasherFn\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * @type {LoadHasherFn}\n */\nconst LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for \"${codeOrName}\"`))\n\nexport class Multihashes {\n  /**\n   * @param {object} options\n   * @param {LoadHasherFn} [options.loadHasher]\n   * @param {MultihashHasher[]} options.hashers\n   */\n  constructor (options) {\n    // Object with current list of active hashers\n    /** @type {Record<string, MultihashHasher>}} */\n    this._hashersByName = {}\n\n    // Object with current list of active hashers\n    /** @type {Record<number, MultihashHasher>}} */\n    this._hashersByCode = {}\n\n    this._loadHasher = options.loadHasher || LOAD_HASHER\n\n    // Enable all supplied hashers\n    for (const hasher of options.hashers) {\n      this.addHasher(hasher)\n    }\n  }\n\n  /**\n   * Add support for a multibase hasher\n   *\n   * @param {MultihashHasher} hasher\n   */\n  addHasher (hasher) {\n    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {\n      throw new Error(`Resolver already exists for codec \"${hasher.name}\"`)\n    }\n\n    this._hashersByName[hasher.name] = hasher\n    this._hashersByCode[hasher.code] = hasher\n  }\n\n  /**\n   * Remove support for a multibase hasher\n   *\n   * @param {MultihashHasher} hasher\n   */\n  removeHasher (hasher) {\n    delete this._hashersByName[hasher.name]\n    delete this._hashersByCode[hasher.code]\n  }\n\n  /**\n   * @param {number | string} code\n   */\n  async getHasher (code) {\n    const table = typeof code === 'string' ? this._hashersByName : this._hashersByCode\n\n    if (table[code]) {\n      return table[code]\n    }\n\n    // If not supported, attempt to dynamically load this hasher\n    const hasher = await this._loadHasher(code)\n\n    if (table[code] == null) {\n      this.addHasher(hasher)\n    }\n\n    return hasher\n  }\n\n  listHashers () {\n    return Object.values(this._hashersByName)\n  }\n}\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAMA,WAAW,GAAG,SAAdA,WAAW,CAAIC,UAAU;EAAA,OAAKC,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,iCAAyBH,UAAU,QAAI,CAAC;AAAA;AAEpG,WAAaI,WAAW;EACtB;AACF;AACA;AACA;AACA;EACE,qBAAaC,OAAO,EAAE;IAAA;IACpB;IACA;IACA,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;;IAExB;IACA;IACA,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IAExB,IAAI,CAACC,WAAW,GAAGH,OAAO,CAACI,UAAU,IAAIV,WAAW;;IAEpD;IAAA,2CACqBM,OAAO,CAACK,OAAO;MAAA;IAAA;MAApC,oDAAsC;QAAA,IAA3BC,MAAM;QACf,IAAI,CAACC,SAAS,CAACD,MAAM,CAAC;MACxB;IAAC;MAAA;IAAA;MAAA;IAAA;EACH;;EAEA;AACF;AACA;AACA;AACA;EAJE;IAAA;IAAA,OAKA,mBAAWA,MAAM,EAAE;MACjB,IAAI,IAAI,CAACL,cAAc,CAACK,MAAM,CAACE,IAAI,CAAC,IAAI,IAAI,CAACN,cAAc,CAACI,MAAM,CAACG,IAAI,CAAC,EAAE;QACxE,MAAM,IAAIX,KAAK,+CAAuCQ,MAAM,CAACE,IAAI,QAAI;MACvE;MAEA,IAAI,CAACP,cAAc,CAACK,MAAM,CAACE,IAAI,CAAC,GAAGF,MAAM;MACzC,IAAI,CAACJ,cAAc,CAACI,MAAM,CAACG,IAAI,CAAC,GAAGH,MAAM;IAC3C;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA;IAAA,OAKA,sBAAcA,MAAM,EAAE;MACpB,OAAO,IAAI,CAACL,cAAc,CAACK,MAAM,CAACE,IAAI,CAAC;MACvC,OAAO,IAAI,CAACN,cAAc,CAACI,MAAM,CAACG,IAAI,CAAC;IACzC;;IAEA;AACF;AACA;EAFE;IAAA;IAAA;MAAA,4EAGA,iBAAiBA,IAAI;QAAA;QAAA;UAAA;YAAA;cAAA;gBACbC,KAAK,GAAG,OAAOD,IAAI,KAAK,QAAQ,GAAG,IAAI,CAACR,cAAc,GAAG,IAAI,CAACC,cAAc;gBAAA,KAE9EQ,KAAK,CAACD,IAAI,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,iCACNC,KAAK,CAACD,IAAI,CAAC;cAAA;gBAAA;gBAAA,OAIC,IAAI,CAACN,WAAW,CAACM,IAAI,CAAC;cAAA;gBAArCH,MAAM;gBAEZ,IAAII,KAAK,CAACD,IAAI,CAAC,IAAI,IAAI,EAAE;kBACvB,IAAI,CAACF,SAAS,CAACD,MAAM,CAAC;gBACxB;gBAAC,iCAEMA,MAAM;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACd;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAED,uBAAe;MACb,OAAOK,MAAM,CAACC,MAAM,CAAC,IAAI,CAACX,cAAc,CAAC;IAC3C;EAAC;EAAA;AAAA"},"metadata":{},"sourceType":"module"}