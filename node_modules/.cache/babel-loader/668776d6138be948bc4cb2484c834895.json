{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { logger } from '@libp2p/logger';\nimport { configure } from '../lib/configure.js';\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js';\nimport { textToUrlSafeRpc, rpcToText, rpcToBytes, rpcToBigInt } from '../lib/http-rpc-wire-format.js';\nimport { peerIdFromString } from '@libp2p/peer-id';\nvar log = logger('ipfs-http-client:pubsub:subscribe');\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker\n */\nexport var createSubscribe = function createSubscribe(options, subsTracker) {\n  return configure(function (api) {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    function subscribe(_x, _x2) {\n      return _subscribe.apply(this, arguments);\n    }\n    function _subscribe() {\n      _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(topic, handler) {\n        var options,\n          done,\n          fail,\n          result,\n          ffWorkaround,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n                // eslint-disable-line require-await\n                options.signal = subsTracker.subscribe(topic, handler, options.signal);\n\n                /** @type {(value?: any) => void} */\n                result = new Promise(function (resolve, reject) {\n                  done = resolve;\n                  fail = reject;\n                }); // In Firefox, the initial call to fetch does not resolve until some data\n                // is received. If this doesn't happen within 1 second assume success\n                ffWorkaround = setTimeout(function () {\n                  return done();\n                }, 1000); // Do this async to not block Firefox\n                api.post('pubsub/sub', {\n                  signal: options.signal,\n                  searchParams: toUrlSearchParams(_objectSpread({\n                    arg: textToUrlSafeRpc(topic)\n                  }, options)),\n                  headers: options.headers\n                }).catch(function (err) {\n                  // Initial subscribe fail, ensure we clean up\n                  subsTracker.unsubscribe(topic, handler);\n                  fail(err);\n                }).then(function (response) {\n                  clearTimeout(ffWorkaround);\n                  if (!response) {\n                    // if there was no response, the subscribe failed\n                    return;\n                  }\n                  readMessages(response, {\n                    onMessage: function onMessage(message) {\n                      if (!handler) {\n                        return;\n                      }\n                      if (typeof handler === 'function') {\n                        handler(message);\n                        return;\n                      }\n                      if (typeof handler.handleEvent === 'function') {\n                        handler.handleEvent(message);\n                      }\n                    },\n                    onEnd: function onEnd() {\n                      return subsTracker.unsubscribe(topic, handler);\n                    },\n                    onError: options.onError\n                  });\n                  done();\n                });\n                return _context.abrupt(\"return\", result);\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return _subscribe.apply(this, arguments);\n    }\n    return subscribe;\n  })(options);\n};\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nfunction readMessages(_x3, _x4) {\n  return _readMessages.apply(this, arguments);\n}\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nfunction _readMessages() {\n  _readMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(response, _ref) {\n    var onMessage, onEnd, onError, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, msg, _msg$key, _msg$signature;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            onMessage = _ref.onMessage, onEnd = _ref.onEnd, onError = _ref.onError;\n            onError = onError || log;\n            _context2.prev = 2;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context2.prev = 5;\n            _iterator = _asyncIterator(response.ndjson());\n          case 7:\n            _context2.next = 9;\n            return _iterator.next();\n          case 9:\n            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n              _context2.next = 24;\n              break;\n            }\n            msg = _step.value;\n            _context2.prev = 11;\n            if (msg.from) {\n              _context2.next = 14;\n              break;\n            }\n            return _context2.abrupt(\"continue\", 21);\n          case 14:\n            if (msg.from != null && msg.seqno != null) {\n              onMessage({\n                type: 'signed',\n                from: peerIdFromString(msg.from),\n                data: rpcToBytes(msg.data),\n                sequenceNumber: rpcToBigInt(msg.seqno),\n                topic: rpcToText(msg.topicIDs[0]),\n                key: rpcToBytes((_msg$key = msg.key) !== null && _msg$key !== void 0 ? _msg$key : 'u'),\n                signature: rpcToBytes((_msg$signature = msg.signature) !== null && _msg$signature !== void 0 ? _msg$signature : 'u')\n              });\n            } else {\n              onMessage({\n                type: 'unsigned',\n                data: rpcToBytes(msg.data),\n                topic: rpcToText(msg.topicIDs[0])\n              });\n            }\n            _context2.next = 21;\n            break;\n          case 17:\n            _context2.prev = 17;\n            _context2.t0 = _context2[\"catch\"](11);\n            _context2.t0.message = \"Failed to parse pubsub message: \".concat(_context2.t0.message);\n            onError(_context2.t0, false, msg); // Not fatal\n          case 21:\n            _iteratorAbruptCompletion = false;\n            _context2.next = 7;\n            break;\n          case 24:\n            _context2.next = 30;\n            break;\n          case 26:\n            _context2.prev = 26;\n            _context2.t1 = _context2[\"catch\"](5);\n            _didIteratorError = true;\n            _iteratorError = _context2.t1;\n          case 30:\n            _context2.prev = 30;\n            _context2.prev = 31;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context2.next = 35;\n              break;\n            }\n            _context2.next = 35;\n            return _iterator.return();\n          case 35:\n            _context2.prev = 35;\n            if (!_didIteratorError) {\n              _context2.next = 38;\n              break;\n            }\n            throw _iteratorError;\n          case 38:\n            return _context2.finish(35);\n          case 39:\n            return _context2.finish(30);\n          case 40:\n            _context2.next = 45;\n            break;\n          case 42:\n            _context2.prev = 42;\n            _context2.t2 = _context2[\"catch\"](2);\n            if (!isAbortError(_context2.t2)) {\n              onError(_context2.t2, true); // Fatal\n            }\n          case 45:\n            _context2.prev = 45;\n            onEnd();\n            return _context2.finish(45);\n          case 48:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 42, 45, 48], [5, 26, 30, 40], [11, 17], [31,, 35, 39]]);\n  }));\n  return _readMessages.apply(this, arguments);\n}\nvar isAbortError = function isAbortError(error) {\n  switch (error.type) {\n    case 'aborted':\n      return true;\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true;\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError';\n  }\n};","map":{"version":3,"names":["logger","configure","toUrlSearchParams","textToUrlSafeRpc","rpcToText","rpcToBytes","rpcToBigInt","peerIdFromString","log","createSubscribe","options","subsTracker","api","subscribe","topic","handler","signal","result","Promise","resolve","reject","done","fail","ffWorkaround","setTimeout","post","searchParams","arg","headers","catch","err","unsubscribe","then","response","clearTimeout","readMessages","onMessage","message","handleEvent","onEnd","onError","ndjson","msg","from","seqno","type","data","sequenceNumber","topicIDs","key","signature","isAbortError","error","name"],"sources":["C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/ipfs-http-client/src/pubsub/subscribe.js"],"sourcesContent":["import { logger } from '@libp2p/logger'\nimport { configure } from '../lib/configure.js'\nimport { toUrlSearchParams } from '../lib/to-url-search-params.js'\nimport { textToUrlSafeRpc, rpcToText, rpcToBytes, rpcToBigInt } from '../lib/http-rpc-wire-format.js'\nimport { peerIdFromString } from '@libp2p/peer-id'\nconst log = logger('ipfs-http-client:pubsub:subscribe')\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker').SubscriptionTracker} subsTracker\n */\nexport const createSubscribe = (options, subsTracker) => {\n  return configure((api) => {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    async function subscribe (topic, handler, options = {}) { // eslint-disable-line require-await\n      options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n      /** @type {(value?: any) => void} */\n      let done\n      /** @type {(error: Error) => void} */\n      let fail\n\n      const result = new Promise((resolve, reject) => {\n        done = resolve\n        fail = reject\n      })\n\n      // In Firefox, the initial call to fetch does not resolve until some data\n      // is received. If this doesn't happen within 1 second assume success\n      const ffWorkaround = setTimeout(() => done(), 1000)\n\n      // Do this async to not block Firefox\n      api.post('pubsub/sub', {\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: textToUrlSafeRpc(topic),\n          ...options\n        }),\n        headers: options.headers\n      })\n        .catch((err) => {\n          // Initial subscribe fail, ensure we clean up\n          subsTracker.unsubscribe(topic, handler)\n\n          fail(err)\n        })\n        .then((response) => {\n          clearTimeout(ffWorkaround)\n\n          if (!response) {\n            // if there was no response, the subscribe failed\n            return\n          }\n\n          readMessages(response, {\n            onMessage: (message) => {\n              if (!handler) {\n                return\n              }\n\n              if (typeof handler === 'function') {\n                handler(message)\n                return\n              }\n\n              if (typeof handler.handleEvent === 'function') {\n                handler.handleEvent(message)\n              }\n            },\n            onEnd: () => subsTracker.unsubscribe(topic, handler),\n            onError: options.onError\n          })\n\n          done()\n        })\n\n      return result\n    }\n    return subscribe\n  })(options)\n}\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nasync function readMessages (response, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of response.ndjson()) {\n      try {\n        if (!msg.from) {\n          continue\n        }\n\n        if (msg.from != null && msg.seqno != null) {\n          onMessage({\n            type: 'signed',\n            from: peerIdFromString(msg.from),\n            data: rpcToBytes(msg.data),\n            sequenceNumber: rpcToBigInt(msg.seqno),\n            topic: rpcToText(msg.topicIDs[0]),\n            key: rpcToBytes(msg.key ?? 'u'),\n            signature: rpcToBytes(msg.signature ?? 'u')\n          })\n        } else {\n          onMessage({\n            type: 'unsigned',\n            data: rpcToBytes(msg.data),\n            topic: rpcToText(msg.topicIDs[0])\n          })\n        }\n      } catch (/** @type {any} */ err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (/** @type {any} */ err) {\n    if (!isAbortError(err)) {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nconst isAbortError = error => {\n  switch (error.type) {\n    case 'aborted':\n      return true\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError'\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}