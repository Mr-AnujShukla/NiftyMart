{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _inherits from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/HP/Desktop/my_workspace/hackathon/NFT/Pixelate/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CID } from 'multiformats/cid';\nimport { bases } from 'multiformats/basics';\nimport { base58btc } from 'multiformats/bases/base58';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport errcode from 'err-code';\nimport { symbol } from '@libp2p/interface-peer-id';\nvar baseDecoder = Object.values(bases).map(function (codec) {\n  return codec.decoder;\n})\n// @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n.reduce(function (acc, curr) {\n  return acc.or(curr);\n}, bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nvar LIBP2P_KEY_CODE = 0x72;\nvar MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nvar MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nvar PeerIdImpl = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function PeerIdImpl(init) {\n    _classCallCheck(this, PeerIdImpl);\n    this.type = init.type;\n    this.multihash = init.multihash;\n    this.privateKey = init.privateKey;\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    });\n  }\n  _createClass(PeerIdImpl, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return \"PeerId(\".concat(this.toString(), \")\");\n    }\n  }, {\n    key: symbol,\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.string == null) {\n        this.string = base58btc.encode(this.multihash.bytes).slice(1);\n      }\n      return this.string;\n    }\n    // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  }, {\n    key: \"toCID\",\n    value: function toCID() {\n      return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.multihash.bytes;\n    }\n    /**\n     * Returns Multiaddr as a JSON encoded object\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(id) {\n      var _id$multihash;\n      if (id instanceof Uint8Array) {\n        return uint8ArrayEquals(this.multihash.bytes, id);\n      } else if (typeof id === 'string') {\n        return peerIdFromString(id).equals(this);\n      } else if ((id === null || id === void 0 ? void 0 : (_id$multihash = id.multihash) === null || _id$multihash === void 0 ? void 0 : _id$multihash.bytes) != null) {\n        return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n  }]);\n  return PeerIdImpl;\n}(Symbol.toStringTag);\nvar RSAPeerIdImpl = /*#__PURE__*/function (_PeerIdImpl) {\n  _inherits(RSAPeerIdImpl, _PeerIdImpl);\n  var _super = _createSuper(RSAPeerIdImpl);\n  function RSAPeerIdImpl(init) {\n    var _this;\n    _classCallCheck(this, RSAPeerIdImpl);\n    _this = _super.call(this, _objectSpread(_objectSpread({}, init), {}, {\n      type: 'RSA'\n    }));\n    _this.type = 'RSA';\n    _this.publicKey = init.publicKey;\n    return _this;\n  }\n  return _createClass(RSAPeerIdImpl);\n}(PeerIdImpl);\nvar Ed25519PeerIdImpl = /*#__PURE__*/function (_PeerIdImpl2) {\n  _inherits(Ed25519PeerIdImpl, _PeerIdImpl2);\n  var _super2 = _createSuper(Ed25519PeerIdImpl);\n  function Ed25519PeerIdImpl(init) {\n    var _this2;\n    _classCallCheck(this, Ed25519PeerIdImpl);\n    _this2 = _super2.call(this, _objectSpread(_objectSpread({}, init), {}, {\n      type: 'Ed25519'\n    }));\n    _this2.type = 'Ed25519';\n    _this2.publicKey = init.multihash.digest;\n    return _this2;\n  }\n  return _createClass(Ed25519PeerIdImpl);\n}(PeerIdImpl);\nvar Secp256k1PeerIdImpl = /*#__PURE__*/function (_PeerIdImpl3) {\n  _inherits(Secp256k1PeerIdImpl, _PeerIdImpl3);\n  var _super3 = _createSuper(Secp256k1PeerIdImpl);\n  function Secp256k1PeerIdImpl(init) {\n    var _this3;\n    _classCallCheck(this, Secp256k1PeerIdImpl);\n    _this3 = _super3.call(this, _objectSpread(_objectSpread({}, init), {}, {\n      type: 'secp256k1'\n    }));\n    _this3.type = 'secp256k1';\n    _this3.publicKey = init.multihash.digest;\n    return _this3;\n  }\n  return _createClass(Secp256k1PeerIdImpl);\n}(PeerIdImpl);\nexport function createPeerId(init) {\n  return new PeerIdImpl(init);\n}\nexport function peerIdFromPeerId(other) {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other);\n  }\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other);\n  }\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other);\n  }\n  throw errcode(new Error('Not a PeerId'), 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n  var _decoder;\n  decoder = (_decoder = decoder) !== null && _decoder !== void 0 ? _decoder : baseDecoder;\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    var multihash = Digest.decode(base58btc.decode(\"z\".concat(str)));\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({\n        multihash: multihash\n      });\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({\n        multihash: multihash\n      });\n    } else {\n      return new RSAPeerIdImpl({\n        multihash: multihash\n      });\n    }\n  }\n  return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n  try {\n    var multihash = Digest.decode(buf);\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({\n          multihash: multihash\n        });\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({\n          multihash: multihash\n        });\n      }\n    }\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({\n        multihash: multihash\n      });\n    }\n  } catch (_unused) {\n    return peerIdFromCID(CID.decode(buf));\n  }\n  throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n  var multihash = cid.multihash;\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({\n      multihash: cid.multihash\n    });\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({\n        multihash: cid.multihash\n      });\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({\n        multihash: cid.multihash\n      });\n    }\n  }\n  throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport function peerIdFromKeys(_x, _x2) {\n  return _peerIdFromKeys.apply(this, arguments);\n}\nfunction _peerIdFromKeys() {\n  _peerIdFromKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(publicKey, privateKey) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\", new Ed25519PeerIdImpl({\n              multihash: Digest.create(identity.code, publicKey),\n              privateKey: privateKey\n            }));\n          case 2:\n            if (!(publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)) {\n              _context.next = 4;\n              break;\n            }\n            return _context.abrupt(\"return\", new Secp256k1PeerIdImpl({\n              multihash: Digest.create(identity.code, publicKey),\n              privateKey: privateKey\n            }));\n          case 4:\n            _context.t0 = RSAPeerIdImpl;\n            _context.next = 7;\n            return sha256.digest(publicKey);\n          case 7:\n            _context.t1 = _context.sent;\n            _context.t2 = publicKey;\n            _context.t3 = privateKey;\n            _context.t4 = {\n              multihash: _context.t1,\n              publicKey: _context.t2,\n              privateKey: _context.t3\n            };\n            return _context.abrupt(\"return\", new _context.t0(_context.t4));\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _peerIdFromKeys.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["CID","bases","base58btc","Digest","identity","equals","uint8ArrayEquals","sha256","errcode","symbol","baseDecoder","Object","values","map","codec","decoder","reduce","acc","curr","or","LIBP2P_KEY_CODE","MARSHALLED_ED225519_PUBLIC_KEY_LENGTH","MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH","PeerIdImpl","init","type","multihash","privateKey","defineProperty","enumerable","writable","toString","string","encode","bytes","slice","createV1","id","Uint8Array","peerIdFromString","Error","Symbol","toStringTag","RSAPeerIdImpl","publicKey","Ed25519PeerIdImpl","digest","Secp256k1PeerIdImpl","createPeerId","peerIdFromPeerId","other","str","charAt","decode","startsWith","peerIdFromBytes","buf","code","length","peerIdFromCID","cid","version","peerIdFromKeys","create"],"sources":["C:\\Users\\HP\\Desktop\\my_workspace\\hackathon\\NFT\\Pixelate\\node_modules\\@libp2p\\peer-id\\src\\index.ts"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { bases } from 'multiformats/basics'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport errcode from 'err-code'\nimport { Ed25519PeerId, RSAPeerId, Secp256k1PeerId, symbol } from '@libp2p/interface-peer-id'\nimport type { MultibaseDecoder } from 'multiformats/bases/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\nimport type { PeerId } from '@libp2p/interface-peer-id'\n\nconst baseDecoder = Object\n  .values(bases)\n  .map(codec => codec.decoder)\n  // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n  .reduce((acc, curr) => acc.or(curr), bases.identity.decoder)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37\n\ninterface PeerIdInit {\n  type: 'RSA' | 'Ed25519' | 'secp256k1'\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n  publicKey?: Uint8Array\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\nclass PeerIdImpl {\n  public type: 'RSA' | 'Ed25519' | 'secp256k1'\n  public readonly multihash: MultihashDigest\n  public readonly privateKey?: Uint8Array\n  public readonly publicKey?: Uint8Array\n  private string?: string\n\n  constructor (init: PeerIdInit) {\n    this.type = init.type\n    this.multihash = init.multihash\n    this.privateKey = init.privateKey\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return `PeerId(${this.toString()})`\n  }\n\n  get [symbol] () {\n    return true\n  }\n\n  toString () {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID () {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toBytes () {\n    return this.multihash.bytes\n  }\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id: PeerId | Uint8Array | string): boolean {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return peerIdFromString(id).equals(this as PeerId)\n    } else if (id?.multihash?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n}\n\nclass RSAPeerIdImpl extends PeerIdImpl implements RSAPeerId {\n  public readonly type = 'RSA'\n  public readonly publicKey?: Uint8Array\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nclass Ed25519PeerIdImpl extends PeerIdImpl implements Ed25519PeerId {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nclass Secp256k1PeerIdImpl extends PeerIdImpl implements Secp256k1PeerId {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nexport function createPeerId (init: PeerIdInit) {\n  return new PeerIdImpl(init)\n}\n\nexport function peerIdFromPeerId (other: any): PeerId {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other)\n  }\n\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other)\n  }\n\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other)\n  }\n\n  throw errcode(new Error('Not a PeerId'), 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): PeerId {\n  decoder = decoder ?? baseDecoder\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    const multihash = Digest.decode(base58btc.decode(`z${str}`))\n\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({ multihash })\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({ multihash })\n    } else {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  }\n\n  return peerIdFromBytes(baseDecoder.decode(str))\n}\n\nexport function peerIdFromBytes (buf: Uint8Array) {\n  try {\n    const multihash = Digest.decode(buf)\n\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash })\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash })\n      }\n    }\n\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  } catch {\n    return peerIdFromCID(CID.decode(buf))\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): PeerId {\n  if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  const multihash = cid.multihash\n\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({ multihash: cid.multihash })\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({ multihash: cid.multihash })\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({ multihash: cid.multihash })\n    }\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys (publicKey: Uint8Array, privateKey?: Uint8Array): Promise<PeerId> {\n  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n    return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n    return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey })\n}\n"]},"metadata":{},"sourceType":"module"}